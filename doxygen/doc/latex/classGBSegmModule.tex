\section{G\+B\+Segm\+Module Class Reference}
\label{classGBSegmModule}\index{G\+B\+Segm\+Module@{G\+B\+Segm\+Module}}


Segmentation Module.  




{\ttfamily \#include $<$Segm\+Module.\+h$>$}

Inheritance diagram for G\+B\+Segm\+Module\+:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=2.000000cm]{classGBSegmModule}
\end{center}
\end{figure}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
virtual bool {\bfseries configure} (yarp\+::os\+::\+Resource\+Finder \&rf)\label{classGBSegmModule_ada22cbfc66dd9b75a7a824e1ce642639}

\item 
virtual bool {\bfseries close} ()\label{classGBSegmModule_ac3259b29883674bf47aa962f54806913}

\item 
virtual bool {\bfseries interrupt\+Module} ()\label{classGBSegmModule_a99b9908ade3135dd5ee491b799d5e171}

\item 
virtual bool {\bfseries update\+Module} ()\label{classGBSegmModule_a66f40b6ae480a039a2c10f6b91c59dde}

\item 
bool {\bfseries attach} (yarp\+::os\+::\+Port \&source)\label{classGBSegmModule_a4ae8d5fee391d799299a10e09a5ea8c4}

\item 
virtual void \hyperlink{classGBSegmModule_a27ffe08d394d321d9f9441423d36ef5e}{set\+\_\+sigma} (const double new\+Value)
\begin{DoxyCompactList}\small\item\em Set sigma (smoothing) parameter for the algorithm. \end{DoxyCompactList}\item 
virtual void \hyperlink{classGBSegmModule_a15129913273e221a46c428f697e40575}{set\+\_\+k} (const double new\+Value)
\begin{DoxyCompactList}\small\item\em Set k (scale factor for boundary-\/detection threshold function) parameter for the algorithm. \end{DoxyCompactList}\item 
virtual void \hyperlink{classGBSegmModule_ae1c722c9c774cbde4f6bfada3f0826ba}{set\+\_\+min\+Region} (const double new\+Value)
\begin{DoxyCompactList}\small\item\em Set min\+Region parameter for the algorithm, i.\+e., the minimum size of any segmented component. \end{DoxyCompactList}\item 
virtual double \hyperlink{classGBSegmModule_ae32ae1b1461e19c3a1b2f429c729ed03}{get\+\_\+sigma} ()
\begin{DoxyCompactList}\small\item\em Get sigma (smoothing) parameter for the algorithm. \end{DoxyCompactList}\item 
virtual double \hyperlink{classGBSegmModule_a44bab99aa7a035e57a185673c040d2f6}{get\+\_\+k} ()
\begin{DoxyCompactList}\small\item\em Get k (scale factor for boundary-\/detection threshold function) parameter for the algorithm. \end{DoxyCompactList}\item 
virtual double \hyperlink{classGBSegmModule_a2378b95e60b406a119947aa86b5bb9c4}{get\+\_\+min\+Region} ()
\begin{DoxyCompactList}\small\item\em Get min\+Region parameter for the algorithm, i.\+e., the minimum size of any segmented component. \end{DoxyCompactList}\item 
virtual int32\+\_\+t \hyperlink{classGBSegmModule_a655ee7c895eed07b07099133b9d8ce68}{get\+\_\+num\+\_\+components} ()
\begin{DoxyCompactList}\small\item\em Get the number of segmented components that have been detected in the last provided image. \end{DoxyCompactList}\item 
virtual std\+::vector\\*
$<$ \hyperlink{classyarp_1_1sig_1_1Pixel}{yarp\+::sig\+::\+Pixel} $>$ \hyperlink{classGBSegmModule_a0b63c53513e67c4f126e29cf7f28ad53}{get\+\_\+component\+\_\+around} (const \hyperlink{classyarp_1_1sig_1_1Pixel}{yarp\+::sig\+::\+Pixel} \&obj\+Center)
\begin{DoxyCompactList}\small\item\em Get the list of pixels corresponding to the component to which a given pixel belongs. \end{DoxyCompactList}\item 
virtual bool {\bfseries read} (yarp\+::os\+::\+Connection\+Reader \&connection)\label{classyarp_1_1sig_1_1SegmentationModuleInterface_ae35adf3fde4e4dd6e2dea92b6e396794}

\end{DoxyCompactItemize}


\subsection{Detailed Description}
Segmentation Module. 



Definition at line 37 of file Segm\+Module.\+h.



\subsection{Member Function Documentation}
\index{G\+B\+Segm\+Module@{G\+B\+Segm\+Module}!get\+\_\+component\+\_\+around@{get\+\_\+component\+\_\+around}}
\index{get\+\_\+component\+\_\+around@{get\+\_\+component\+\_\+around}!G\+B\+Segm\+Module@{G\+B\+Segm\+Module}}
\subsubsection[{get\+\_\+component\+\_\+around}]{\setlength{\rightskip}{0pt plus 5cm}std\+::vector$<$ {\bf Pixel} $>$ G\+B\+Segm\+Module\+::get\+\_\+component\+\_\+around (
\begin{DoxyParamCaption}
\item[{const {\bf yarp\+::sig\+::\+Pixel} \&}]{obj\+Center}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\label{classGBSegmModule_a0b63c53513e67c4f126e29cf7f28ad53}


Get the list of pixels corresponding to the component to which a given pixel belongs. 


\begin{DoxyParams}{Parameters}
{\em obj\+Center} & a pixel belonging to the region of interest \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
list of pixels belonging to the same component as the input pixels 
\end{DoxyReturn}


Reimplemented from \hyperlink{classyarp_1_1sig_1_1SegmentationModuleInterface_a9bf0b95fbab216b2284122b0b8a36820}{yarp\+::sig\+::\+Segmentation\+Module\+Interface}.



Definition at line 72 of file Segm\+Module.\+cpp.



References yarp\+::sig\+::\+Pixel\+::x, and yarp\+::sig\+::\+Pixel\+::y.


\begin{DoxyCode}
73 \{
74     vector<Pixel> result;
75     result.clear();
76     segMutex.wait();
77     rgb componentColor = imRef(seg, objCenter.x, objCenter.y);
78     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} y = 0; y < seg->height(); y++) \{
79 
80             \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} x = 0; x < seg->width(); x++) \{
81 
82               \textcolor{keywordflow}{if} (imRef(seg, x, y) == componentColor)
83                 result.push\_back(Pixel(x, y));
84 
85 
86             \}
87 
88         \}
89 
90     
91     segMutex.post();
92     \textcolor{keywordflow}{return} result;
93 
94 \}
\end{DoxyCode}
\index{G\+B\+Segm\+Module@{G\+B\+Segm\+Module}!get\+\_\+k@{get\+\_\+k}}
\index{get\+\_\+k@{get\+\_\+k}!G\+B\+Segm\+Module@{G\+B\+Segm\+Module}}
\subsubsection[{get\+\_\+k}]{\setlength{\rightskip}{0pt plus 5cm}double G\+B\+Segm\+Module\+::get\+\_\+k (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\label{classGBSegmModule_a44bab99aa7a035e57a185673c040d2f6}


Get k (scale factor for boundary-\/detection threshold function) parameter for the algorithm. 

\begin{DoxyReturn}{Returns}
current value for k parameter 
\end{DoxyReturn}


Reimplemented from \hyperlink{classyarp_1_1sig_1_1SegmentationModuleInterface_a91f3d872a48599337d1d2f365ac4c31e}{yarp\+::sig\+::\+Segmentation\+Module\+Interface}.



Definition at line 69 of file Segm\+Module.\+cpp.


\begin{DoxyCode}
69 \{\textcolor{keywordflow}{return} k;\}
\end{DoxyCode}
\index{G\+B\+Segm\+Module@{G\+B\+Segm\+Module}!get\+\_\+min\+Region@{get\+\_\+min\+Region}}
\index{get\+\_\+min\+Region@{get\+\_\+min\+Region}!G\+B\+Segm\+Module@{G\+B\+Segm\+Module}}
\subsubsection[{get\+\_\+min\+Region}]{\setlength{\rightskip}{0pt plus 5cm}double G\+B\+Segm\+Module\+::get\+\_\+min\+Region (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\label{classGBSegmModule_a2378b95e60b406a119947aa86b5bb9c4}


Get min\+Region parameter for the algorithm, i.\+e., the minimum size of any segmented component. 

\begin{DoxyReturn}{Returns}
current value for min\+Region parameter 
\end{DoxyReturn}


Reimplemented from \hyperlink{classyarp_1_1sig_1_1SegmentationModuleInterface_a6c184aeea894f6afcc342c5aa748429d}{yarp\+::sig\+::\+Segmentation\+Module\+Interface}.



Definition at line 70 of file Segm\+Module.\+cpp.


\begin{DoxyCode}
70 \{\textcolor{keywordflow}{return} min\_size;\}
\end{DoxyCode}
\index{G\+B\+Segm\+Module@{G\+B\+Segm\+Module}!get\+\_\+num\+\_\+components@{get\+\_\+num\+\_\+components}}
\index{get\+\_\+num\+\_\+components@{get\+\_\+num\+\_\+components}!G\+B\+Segm\+Module@{G\+B\+Segm\+Module}}
\subsubsection[{get\+\_\+num\+\_\+components}]{\setlength{\rightskip}{0pt plus 5cm}int32\+\_\+t G\+B\+Segm\+Module\+::get\+\_\+num\+\_\+components (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\label{classGBSegmModule_a655ee7c895eed07b07099133b9d8ce68}


Get the number of segmented components that have been detected in the last provided image. 

\begin{DoxyReturn}{Returns}
number of segmented components 
\end{DoxyReturn}


Reimplemented from \hyperlink{classyarp_1_1sig_1_1SegmentationModuleInterface_a3c6b695fbef9e6827e7dd6b4cbbc38fe}{yarp\+::sig\+::\+Segmentation\+Module\+Interface}.



Definition at line 71 of file Segm\+Module.\+cpp.


\begin{DoxyCode}
71 \{\textcolor{keywordflow}{return} num\_components;\}
\end{DoxyCode}
\index{G\+B\+Segm\+Module@{G\+B\+Segm\+Module}!get\+\_\+sigma@{get\+\_\+sigma}}
\index{get\+\_\+sigma@{get\+\_\+sigma}!G\+B\+Segm\+Module@{G\+B\+Segm\+Module}}
\subsubsection[{get\+\_\+sigma}]{\setlength{\rightskip}{0pt plus 5cm}double G\+B\+Segm\+Module\+::get\+\_\+sigma (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\label{classGBSegmModule_ae32ae1b1461e19c3a1b2f429c729ed03}


Get sigma (smoothing) parameter for the algorithm. 

\begin{DoxyReturn}{Returns}
current value for sigma parameter 
\end{DoxyReturn}


Reimplemented from \hyperlink{classyarp_1_1sig_1_1SegmentationModuleInterface_a38431f2c63d7da8ebf20adf0ed1da4fe}{yarp\+::sig\+::\+Segmentation\+Module\+Interface}.



Definition at line 68 of file Segm\+Module.\+cpp.


\begin{DoxyCode}
68 \{\textcolor{keywordflow}{return} sigma;\}
\end{DoxyCode}
\index{G\+B\+Segm\+Module@{G\+B\+Segm\+Module}!set\+\_\+k@{set\+\_\+k}}
\index{set\+\_\+k@{set\+\_\+k}!G\+B\+Segm\+Module@{G\+B\+Segm\+Module}}
\subsubsection[{set\+\_\+k}]{\setlength{\rightskip}{0pt plus 5cm}void G\+B\+Segm\+Module\+::set\+\_\+k (
\begin{DoxyParamCaption}
\item[{const double}]{new\+Value}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\label{classGBSegmModule_a15129913273e221a46c428f697e40575}


Set k (scale factor for boundary-\/detection threshold function) parameter for the algorithm. 


\begin{DoxyParams}{Parameters}
{\em new\+Value} & new value for k parameter \\
\hline
\end{DoxyParams}


Reimplemented from \hyperlink{classyarp_1_1sig_1_1SegmentationModuleInterface_a2851eae0226ad68f41cd8b61d8bb1456}{yarp\+::sig\+::\+Segmentation\+Module\+Interface}.



Definition at line 66 of file Segm\+Module.\+cpp.


\begin{DoxyCode}
66 \{k=newValue;\}
\end{DoxyCode}
\index{G\+B\+Segm\+Module@{G\+B\+Segm\+Module}!set\+\_\+min\+Region@{set\+\_\+min\+Region}}
\index{set\+\_\+min\+Region@{set\+\_\+min\+Region}!G\+B\+Segm\+Module@{G\+B\+Segm\+Module}}
\subsubsection[{set\+\_\+min\+Region}]{\setlength{\rightskip}{0pt plus 5cm}void G\+B\+Segm\+Module\+::set\+\_\+min\+Region (
\begin{DoxyParamCaption}
\item[{const double}]{new\+Value}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\label{classGBSegmModule_ae1c722c9c774cbde4f6bfada3f0826ba}


Set min\+Region parameter for the algorithm, i.\+e., the minimum size of any segmented component. 


\begin{DoxyParams}{Parameters}
{\em new\+Value} & new value for min\+Region parameter \\
\hline
\end{DoxyParams}


Reimplemented from \hyperlink{classyarp_1_1sig_1_1SegmentationModuleInterface_ad9d90ed7e362ae83e2145445a9c4301e}{yarp\+::sig\+::\+Segmentation\+Module\+Interface}.



Definition at line 67 of file Segm\+Module.\+cpp.


\begin{DoxyCode}
67 \{min\_size=newValue;\}
\end{DoxyCode}
\index{G\+B\+Segm\+Module@{G\+B\+Segm\+Module}!set\+\_\+sigma@{set\+\_\+sigma}}
\index{set\+\_\+sigma@{set\+\_\+sigma}!G\+B\+Segm\+Module@{G\+B\+Segm\+Module}}
\subsubsection[{set\+\_\+sigma}]{\setlength{\rightskip}{0pt plus 5cm}void G\+B\+Segm\+Module\+::set\+\_\+sigma (
\begin{DoxyParamCaption}
\item[{const double}]{new\+Value}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\label{classGBSegmModule_a27ffe08d394d321d9f9441423d36ef5e}


Set sigma (smoothing) parameter for the algorithm. 


\begin{DoxyParams}{Parameters}
{\em new\+Value} & new value for sigma parameter \\
\hline
\end{DoxyParams}


Reimplemented from \hyperlink{classyarp_1_1sig_1_1SegmentationModuleInterface_a68f28930df5e930934c0ee56ad1f680c}{yarp\+::sig\+::\+Segmentation\+Module\+Interface}.



Definition at line 65 of file Segm\+Module.\+cpp.


\begin{DoxyCode}
65 \{sigma=newValue;\}
\end{DoxyCode}


The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
C\+:/dev/icub-\/contrib-\/iit/segmentation/graph\+Based/Segm\+Module.\+h\item 
C\+:/dev/icub-\/contrib-\/iit/segmentation/graph\+Based/Segm\+Module.\+cpp\end{DoxyCompactItemize}
